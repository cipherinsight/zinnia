use core::array::Array;
use core::array::ArrayTrait;
use core::dict::Felt252Dict;
use core::traits::TryInto;
use core::option::OptionTrait;

fn main(A:[[u64; 10]; 10], a: u64, b: u64, y: u64) {
    assert!(a>=0 && a<10, "a out of bounds");
    assert!(b>=0 && b<10, "b out of bounds");
    assert!(y>=0 && y<=1, "y out of bounds");

    let mut q: Array<u64> = array![];
    let mut visited: Felt252Dict<bool> = Default::default();

    let mut i: u32 = 0;
    while i < 10 {
        visited.insert(i.into(), false);
        i += 1;
    }
    let A_span = A.span();
    let mut As: Array<Span<u64>> = array![];
    while i < 10 {
        let row = A_span[i];
        let row_span = row.span();
        As.append(row_span);
        i += 1;
    }
    q.append(a);
    visited.insert(a.into(), true);
    while q.len() > 0 {
        let node = q.pop_front().unwrap();
        if node == b {
            assert!(y == 1, "y wrong");
            return;
        }
        let mut i: u32 = 0;
        while i < 10 {
            let node_u32: u32 = node.try_into().unwrap();
            let is_connected = As.at(node_u32)[i];
            let is_visited = visited.get(i.into());
            if *is_connected == 1 && !is_visited {
                q.append(i.into());
                visited.insert(i.into(), true);
            }
            i += 1;
        }
    }

    assert!(y == 0, "y wrong");
}